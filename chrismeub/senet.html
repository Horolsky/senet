<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Senet</title>
    <meta name="description" content="Possibly the oldest known board game, Senet is from ancient Egypt. For a game so old, it is surprisingly fun to play. The goal is to transition all your pawns into the afterlife before your opponent. Pawns can attack each other by switching places, and adjacent pawns defend each other from attack. The game is very balanced and replayable.">


    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


    <meta property="og:title" content="Senet">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://chrismeub.com">
    <meta property="og:image" content="http://chrismeub.com/Content/img/favicon.ico">
    <meta property="og:site_name" content="chrismeub.com">


    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/img/favicon.ico" type="image/x-icon">



    <link rel="stylesheet" type="text/css" href="/css/styles.css" media="all">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
        <link href='http://fonts.googleapis.com/css?family=Rokkitt:400,700' rel='stylesheet' type='text/css'>


    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    
    <link rel="stylesheet" type="text/css" href="/css/game.css" media="all" />
    <script src="/js/core.js"></script>
    <script src="/js/zepto.min.js"></script>
    <script src="/js/game.js?v=2"></script>

</head>
<body class="nav_bg article wide" onclick="return gs.on_body_click();" onload="return define_game()">

    <div class="wrapper">
        
<ul class="nav unselectable">
<li><a href="http://chrismeub.com">chrismeub.com</a></li><li class="destination">
      <a href="/projects.html" class="selected">projects</a>
</li><li class="destination">
      <a href="/tools.html" class="unselected">tools</a>
</li><li class="destination">
      <a href="/music.html" class="unselected">music</a>
</li><li class="destination">
      <a href="/about.html" class="unselected">about</a>
</li><li class="destination">
      <a href="/contact.html" class="unselected">contact</a>
</li></ul>

        
<div class="content_wrapper">
   <div class="content" id="">
      
        <div class="heading">
          <h1 class="unselectable">Senet
            <span class="page_date unselectable">by Chris Meub on 1/08/2016</span>
          </h1>
        </div>
      
   









<div class="game_wrapper">
    <div class="game">
        <div class="state"></div>
        <span class="dice"></span><span class="roll"></span>
        <div class="clear"></div>
        <div class="board unselectable"></div>
        <div class="controls">
            <a class="control btn_new_game" href="#">Play Again</a><span class="score"></span>
        </div>
        <div class="clear"></div>
        <div class="debug"></div>
    </div>
</div>


<h3>Goal</h3>
<p>Win by moving all of your Pawns off the board and into the afterlife.</p>
<h3>Rules</h3>
<ul>
<li>The board of Senet is a linear track of 30 squares, following a 'Z' shaped path.</li>
<li>On your turn, roll the dice and move any blue Pawn that many spaces forward.</li>
<li>If a Pawn lands on an opposing pawn, it 'attacks' it and the two Pawns switch places.</li>
<li>Pawns which are next to a friendly pawn are defended and cannot be attacked.</li>
<li>The dice rolls from 1 - 5. Rolling a 1, 4, or 5 grants an extra turn.</li>
<li>If you can advance a piece, you must do so.<ul>
<li>Otherwise, you must move a piece backwards 1 square.</li>
<li>If you cannot do either, your turn is forfeited.</li>
</ul>
</li>
</ul>
<h3>Special Squares</h3>
<ul>
<li>House of Rebirth <img class="tiny" src="/img/senet_rebirth.png"> The square where pawns go from the House of Waters.</li>
<li>House of Beauty <img class="tiny" src="/img/senet_beauty.png"> A mandatory square every pawn must land directly on.</li>
<li>House of Waters <img class="tiny" src="/img/senet_water.png"> Any pawn landing on this square is moved to the House of Rebirth, or behind it if the square is occupied. Any pawn which is attacked on one of the squares after this gets taken to the House of Waters instead of switching places.</li>
<li>House of Three Truths <img class="tiny" src="/img/senet_three.png"> A pawn may only advance on a roll of 3.</li>
<li>House of Re-Atoum <img class="tiny" src="/img/senet_two.png"> A pawn may only advance on a roll of 2.</li>
<li>House of the Scarab <img class="tiny" src="/img/senet_one.png"> A pawn may advance on any roll.</li>
</ul>
<h3>Dice Rolls</h3>
<p>The ancient game of Senet was played with four split sticks, each with a mark on one side. Count the number of clear sides facing up to get a roll between zero and four. A zero was counted as a five. This creates a "normal distribution." Unlike a six-sided die where every number is equally likely, in Senet you have a much higher chance of rolling a two, for example. Even though it looks like this game uses a six-sided die, it actually uses the same probabilities as the sticks in traditional Senet. See the precise probabilities at <a href="http://anydice.com/program/75b6" target="_blank">AnyDice</a>.</p>
<script>
    function define_game()
    {
        var game = gs.initialize_game( $(".game"), "game-small", true,
        [
            [ 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 ],
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        ],
        [
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
            [ 0, 0, 0, 0, 0,
                '<img src="/img/senet_rebirth.png" title="House of Rebirth">',
                0, 0, 0, 0 ],
            [ 0, 0, 0, 0, 0,
                '<img src="/img/senet_beauty.png" title="House of Beauty">',
                '<img src="/img/senet_water.png" title="House of Water">',
                '<img src="/img/senet_three.png" title="House of Three Truths">',
                '<img src="/img/senet_two.png" title="House of Re-Atoum">',
                '<img src="/img/senet_one.png" title="House of the Scarab">'
                ]
        ]);

        var idx_hor = 15;
        var idx_hob = 26;
        var idx_how = 27;
        var idx_hott = 28;
        var idx_hora = 29;
        var idx_hos = 30;
        var idx_aft = 31;

        game.is_loss_if_stuck = false;

        game.ai_depth = 1;
        game.ai_mistake_chance = 0;
        game.ai_wait_ms = function(){ return 400; };

        // player is odd, opponent is even
        game.piece_map =
            {
                0 : "",
                1 : '<span style="color:#365286">☗</span>',
                2 : '<span style="color:#896837">☗</span>'
            };

        // the value for the ai
        game.piece_value_map =
            {
                0 : 0,
                1 : 100,
                2 : -100
            };

        game.roll_dice =
            function()
            {
                // 0 - 4
                var sum = Math.round(Math.random()) +
                          Math.round(Math.random()) +
                          Math.round(Math.random()) +
                          Math.round(Math.random());
                return sum ? sum : 5; // 0 becomes 5
            };

        var is_guarded =
            function( dst, team )
            {
                var dst_idx = to_board_index( dst );
                var prev = from_board_index( dst_idx - 1 );
                var next = from_board_index( dst_idx + 1 );
                if( game.has(prev) && is_team(game.get(prev), team) )
                    return true; //guarded
                if( game.has(next) && is_team(game.get(next), team) )
                    return true; //guarded
                return false;
            };

        var can_team_occupy =
            function( dst, team )
            {
                if( !game.has(dst) )
                    return false;

                var victim = game.get(dst);
                if( !victim )
                    return true;

                var vteam = get_team(victim);
                // cannot occupy friendly.
                if( vteam == team )
                    return false;

                if( is_guarded( dst, vteam ) )
                    return false;

                return true;
            };

        // this AI completely relies on estimation, not minimax.
        game.estimation =
            function(depth, literal_depth)
            {
                // 100 points for each piece we get off the board
                var est = game.total_piece_value;

                // check each cell
                var has_0 = false;
                var has_1 = false;
                var last_guard = -1;
                var can_move_2 = [false,false];
                var can_move_3 = [false,false];
                for( var i = 1; i <= 30; ++i )
                {
                    var coord = from_board_index(i);
                    var id = game.get(coord);
                    if( !id )
                        continue;
                    var team = get_team(id);

                    if( can_team_occupy( from_board_index(i+2), team ) )
                        can_move_2[team] = true;
                    if( can_team_occupy( from_board_index(i+3), team ) )
                        can_move_3[team] = true;

                    // we are in a better position the farther our pieces are
                    // along the track, and a worse position if player is far along
                    est += (team ? -i : i);

                    // guarding only matters if an enemy is behind us
                    if( ((team == 1 && has_0) || (team == 0 && has_1)) &&
                        is_guarded( coord, team ) )
                    {
                        est += (team ? -7 : 7);
                        last_guard = team;
                    }

                    if( team )
                        has_1 = true;
                    else
                        has_0 = true;
                }

                // bonus to the last defensive blockade
                if( last_guard )
                    est += (last_guard ? -20 : 20);

                // penalize teams who cant move on a 2/3
                if( can_move_2[0] )
                    est += 10;
                if( can_move_2[1] )
                    est -= 10;
                if( can_move_3[0] )
                    est += 10;
                if( can_move_3[1] )
                    est -= 10;

                return est;
            };

        game.gets_extra_turn = 
            function()
            {
                return (game.dice_value == 1 || 
                        game.dice_value == 4 || 
                        game.dice_value == 5);
            };

        var goto_how = 
            function( src, victim, dst, id, visit )
            {
                // find the closest location behind the 
                // house of rebirth to place this piece
                for( var i = idx_hor; i >= 1; --i )
                {
                    var rebirth = from_board_index( i );
                    if( game.get(rebirth) == 0 )
                    {
                        visit( [ src.slice(0), 0, dst, id, rebirth.slice(0), victim ] );
                        return;
                    }
                }
            };

        var pawn_move =
            function( src, id, visit )
            {
                var team = get_team(id);
                var index0 = to_board_index( src );
                var index1 = index0 + game.dice_value;

                if( index0 < idx_hob && index1 > idx_hob )
                    return;// cannot pass the hob
                if( index0 == idx_hott && index1 != idx_aft )
                    return;// must be exact
                if( index0 == idx_hora && index1 != idx_aft )
                    return;// must be exact

                var dst = from_board_index( index1 );

                if( index1 == idx_how )
                {
                    goto_how( src, id, dst, 0, visit );
                    return;
                }

                if( !game.has(dst) )
                {
                    visit( [ src.slice(0), 0, [10,0], 0 ] );
                    return;
                }

                // we have to make sure victim is not guarded
                if( !can_team_occupy(dst, team) )
                    return;

                var victim = game.get(dst);

                // if the victim is in the final 3 squares, 
                // attacking works differently.
                if( victim && index1 > idx_how )
                {
                    // victim is thrown into the water
                    goto_how( src, victim, dst, id, visit );
                    return;
                }

                visit( [ src.slice(0), victim, dst.slice(0), id ] );
            };

        var backward_move =
            function(src, id, visit)
            {
                var index0 = to_board_index( src );
                var index1 = index0 - 1;
                var dst = from_board_index( index1 );
                // backward moves cannot attack an enemy pawn
                if( game.has(dst) && game.get(dst) == 0 )
                {
                    if( index1 == idx_how )
                        goto_how( src, id, dst, 0, visit );
                    else
                        visit( [ src.slice(0), 0, dst.slice(0), id ] );
                }
            };

        game.piece_move_map =
            {
                0 : null,
                1 : pawn_move,
                2 : pawn_move
            };

        // termination conditions
        game.is_player_win =
            function( result )
            {
                return game.piece_count_map[1] <= 0;
            };
        game.is_opponent_win =
            function( result )
            {
                return game.piece_count_map[2] <= 0;
            };

        game.make_all_moves =
            function( visit )
            {
                var found_move = false;

                var make_move =
                    function( move )
                    {
                        found_move = true;

                        var end_turn = !game.gets_extra_turn();

                        // make move
                        var old0 = game.set( move[0], move[1] );
                        var old1 = game.has( move[2] ) ? game.set( move[2], move[3] ) : 0;
                        var old2 = move.length >= 6 ? game.set( move[4], move[5] ) : 0;
                        if( end_turn )
                            game.is_player_turn = !game.is_player_turn;

                        visit( move );

                        // unmake move
                        if( end_turn )
                            game.is_player_turn = !game.is_player_turn;
                        move.length >= 6 && game.set( move[4], old2 );
                        game.has( move[2] ) && game.set( move[2], old1 );
                        game.set( move[0], old0 );
                    };

                // visit all friendly pieces
                var team = game.is_player_turn ? 1 : 0;
                for( var y = 0; y < game.size[1]; ++y )
                    for( var x = 0 ; x < game.size[0]; ++x )
                    {
                        var src = [x,y];
                        var id = game.get( src );
                        if( is_team(id,team) )
                            game.piece_move_map[id]( src, id, make_move );
                    }

                if( found_move )
                    return;

                // we couldnt do any forward moves, so try moving backward
                for( var y = 0; y < game.size[1]; ++y )
                    for( var x = 0 ; x < game.size[0]; ++x )
                    {
                        var src = [x,y];
                        var id = game.get( src );
                        if( is_team(id,team) )
                            backward_move( src, id, make_move );
                    }

                if( found_move )
                    return;

                // if we still couldnt move, we must pass.
                for( var y = 0; y < game.size[1]; ++y )
                    for( var x = 0 ; x < game.size[0]; ++x )
                    {
                        var src = [x,y];
                        var id = game.get( src );
                        if( is_team(id,team) )
                        {
                            make_move( [ src.slice(0), id, src.slice(0), id ] );
                            return;
                        }
                    }
            };

        game.on_player_turn =
            function()
            {
                game.player_can_move = 0;

                var visit = function(){ game.player_can_move=1; };
                for( var y = 0; y < game.size[1]; ++y )
                    for( var x = 0 ; x < game.size[0]; ++x )
                    {
                        var src = [x,y];
                        var id = game.get( src );
                        if( is_team(id,1) )
                            game.piece_move_map[id]( src, id, visit );
                    }

                if( game.player_can_move )
                    return;

                visit = function(){ game.player_can_move=-1; };
                for( var y = 0; y < game.size[1]; ++y )
                    for( var x = 0 ; x < game.size[0]; ++x )
                    {
                        var src = [x,y];
                        var id = game.get( src );
                        if( is_team(id,1) )
                            backward_move( src, id, visit );
                    }

                if( game.player_can_move )
                {
                    game.state.text( "Choose a piece to move backwards." ).fadeIn();
                    return;
                }

                game.state.text( "You cannot move, your turn will be skipped." ).fadeIn();
                setTimeout(
                    function()
                    {
                        game.player_move( [] );
                    },
                    1000 );
            };

        // global action when any cell is selected
        game.cell_select = 
            function()
            {
                if( game.state_index != 0 )
                    return false;

                if( !game.player_can_move )
                    return false;

                var coord = $(this)[0].data;
                var cur_id = game.get(coord);

                // if is a player piece
                if( cur_id && get_team(cur_id) == 1 )
                {
                    game.player_unpick();

                    // moving
                    var id = cur_id;
                    var src = coord;
                    var move = null;

                    if( game.player_can_move < 0 )
                    {
                        game.player_pick( coord, cur_id, backward_move );
                        var dst = from_board_index( to_board_index( src ) - 1 );
                        if( (move=game.is_valid_player_piece_move( dst )) )
                        {
                            game.player_unpick();
                            game.player_move( move );
                            return false;
                        }
                        else
                            game.player_unpick();
                    }
                    else
                    {
                        game.player_pick( coord, cur_id );
                        var dst = from_board_index( to_board_index( src ) + game.dice_value );
                        if( !game.has(dst) )
                            dst = [10,0];

                        if( (move=game.is_valid_player_piece_move( dst )) )
                        {
                            game.player_unpick();
                            game.player_move( move );
                            return false;
                        }
                        else
                        {
                            game.player_unpick();
                            gs.invalid_move( game, game.has(dst) ? dst : src );
                            return false;
                        }
                    }
                }

                gs.invalid_move( game, coord );
                return false;
            };

        game.generic_move =
            function( move, callback )
            {
                var old_id = (move.length >= 2) ? game.set( move[0], move[1] ) : 0;
                move.length >= 4 && game.has( move[2] ) && game.set( move[2], move[3] );
                move.length >= 6 && game.set( move[4], move[5] );

                // animate certain moves...
                if( move.length >= 4 )
                {
                    var squares = gs.distance( move[0], move[2] );
                    if( move.length == 4 )
                    {
                        // 1. move[3] moves from move[0] -> move[2]
                        // 2. move[3] @ move[0] swaps with move[1] @ move[2]
                        // 3. old_id moves off the board from move[0] (both move[1] & move[3] are 0)
                        if( move[1] == 0 )
                        {
                            if( move[3] == 0 )
                                return gs.animate_move( game.piece_at( move[0] ), game.at( [9,0] ), squares,
                                    function(element){ element.remove(); callback(); },
                                    // supply a dst animation offset
                                    [60, 0] );
                            else
                                return gs.animate_move( game.piece_at( move[0] ), game.at( move[2] ), squares, callback );
                        }
                        else // perform exchange
                        {
                            var target = game.piece_at( move[2] );
                            gs.animate_move( game.piece_at( move[0] ), game.at( move[2] ), squares );
                            return gs.animate_move( target, game.at( move[0] ), squares, callback );
                        }
                    }
                    else
                    {
                        if( move[3] == 0 )
                        {
                            // 1. move[5] tried to move from move[0] -> move[2] but was teleported to move[4]
                            return gs.animate_move( game.piece_at( move[0] ), game.at( move[2] ), squares, 
                                function()
                                {
                                    gs.animate_move( game.piece_at( move[2] ), game.at( move[4] ), 
                                        gs.distance( move[2], move[4] ), callback );
                                });
                        }
                        else
                        {
                            // 2. move[3] moved from move[0] -> move[2], kicked move[5] out of move[2] and into move[4]
                            var target = game.piece_at( move[2] );
                            var how = from_board_index(idx_how);
                            gs.animate_move( game.piece_at( move[0] ), game.at( move[2] ), squares );
                            return gs.animate_move( target, game.at( how ), squares,
                                function()
                                {
                                    gs.animate_move( game.piece_at( how ), game.at( move[4] ), 
                                        gs.distance( how, move[4] ), callback );
                                });
                        }
                    }
                }

                // if we dont have an animate for this move, 
                // then we just update the board directly
                game.update_board();
                return callback();
            };

        game.player_move =
            function( move )
            {
                game.generic_move( move, 
                    function()
                    {
                        if( !game.check_finished() )
                        {
                            if( game.gets_extra_turn() )
                            {
                                game.change_state( 0 );
                                if( game.state.text() == "It's your move." )
                                    game.state.text( "You got an extra turn." ).fadeIn();
                            }
                            else
                                game.opponent_move();
                        }
                    });
            };

        game.opponent_move =
            function(wait, had_extra_turn)
            {
                wait = wait || game.ai_wait_ms();
                game.change_state( 1 );
                if( had_extra_turn )
                    game.state.text( "Opponent got extra turn..." ).fadeIn();
                setTimeout(
                    function()
                    {
                        var move = game.ai_choose_move();

                        if( !move )
                        {
                            console.log( "No move was found" );
                            game.change_state( 0 );
                            return;
                        }

                        game.generic_move( move, 
                            function()
                            {
                                if( !game.check_finished() )
                                {
                                    if( game.gets_extra_turn() )
                                        game.opponent_move( game.ai_wait_ms() * 2, true );
                                    else
                                        game.change_state( 0 );
                                }
                            });
                    },
                    wait );
            };

        game.new_game();

        window.game_obj = game;

        return game;
    }

    function to_board_index( src )
    {
        return (2 - src[1])*10 + (src[1] == 1 ? 9 - src[0] : src[0]) + 1;
    }

    function from_board_index( index )
    {
        index -= 1;
        var row = 2 - Math.floor(index/10);
        return [ (row == 1 ? 9 - index % 10 : index % 10), row ];
    }

    function get_team( id )
    {
        return id%2; // remainder
    }

    function is_team( id, team )
    {
        return id && get_team(id) == team;
    }
</script>
   </div>
</div>

        
<p class="copyright">© 2019 Chris Meub</p>
<div class="clear"></div>

    </div>


    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-66369602-1', 'auto');
      ga('send', 'pageview');
    </script>
</body>
</html>
